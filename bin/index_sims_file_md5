#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use Getopt::Long;
use MongoDB;

my $verbose  = 0;
my $in_file  = '';
my $out_file = '';
my $md5_num  = 5000;
my $achhost  = "";
my $achname  = "";
my $achuser  = "";
my $achpass  = "";
my $achver   = "1";
my $usage    = qq($0
Script to index m8 format blast file by 2nd column,
assumning md5sum as entry and sorted by md5sum.
Index will include id, seek, length for every chunck.
'id' is the integer index for the md5sum in the input file, lookup done through mongodb.
Each chunk will contain the same md5sum in 2nd column.

  --in_file      file name           Required. Name of input sim file
  --out_file     file name           Required. Name of output index file
  --md5_num      int                 Optional. Number of md5 chunks to load in memory at once before processing. Default is '$md5_num'
  --ach_host     mongodb host        Required. Mongo server with ach data
  --ach_name     mongodb name        Required. Name of mongo db with ach data
  --ach_user     mongodb user        Required. Owner of mongo db with ach data
  --ach_pass     mongodb password    Required. Password of mongo db with ach data
  --ach_ver      ach version         Required. Version of ach data in mongodb
  --verbose                          Optional. Verbose output.
  
);
if ( (@ARGV > 0) && ($ARGV[0] =~ /-h/) ) { print STDERR $usage; exit 1; }
if ( ! GetOptions( "verbose!"   => \$verbose,
		           "in_file=s"  => \$in_file,
		           "out_file=s" => \$out_file,
		           "md5_num:i"  => \$md5_num,
		           "ach_host=s" => \$achhost,
                   "ach_name=s" => \$achname,
                   "ach_user=s" => \$achuser,
                   "ach_pass=s" => \$achpass,
		           "ach_ver=s"  => \$achver
                 ) )
  { print STDERR $usage; exit 1; }
  
unless ($in_file && (-s $in_file) && $out_file) {
    print STDERR $usage . "Missing input and/or output files.\n"; exit 1;
}

# connect to ACH mongo db
my $ach = undef;
eval {
    my ($mhost, $mport) = split(/:/, $achhost);
    my $mconn = MongoDB::Connection->new(
        host => $mhost,
        port => $mport,
        username => $achuser,
        password => $achpass,
        db_name => $achname
    );
    $mconn->query_timeout(-1);
    my $mdb = $mconn->get_database($achname);
    $ach = $mdb->get_collection('v'.$achver);
};
if ($@ || (! $ach)) {
   print STDERR "Error getting ACH mongodb connection:\n".$@."\n";
   exit 1;
}

print "Parsing file $in_file in $md5_num md5 size chunks ... " if ($verbose);
open(INFILE, "<$in_file") or die "Can't open file $in_file!\n";
open(OUTFILE, ">$out_file") or die "Can't open file $out_file!\n";

my $seeks = [];
my $start = 0;
my $byte  = 0;
my $size  = 0;
my $curr  = '';
my $md5s  = 0;
my $count = 0;

while (my $line = <INFILE>) {
    my @parts = split(/\t/, $line);
    my $md5 = $parts[1];
    if ($curr ne $md5) {
        if ($size > 0) {
            push @$seeks, [ $curr, $start, $size ];
            if ($md5s >= $md5_num) {
                print OUTFILE &process_seeks($ach, $seeks);
                $seeks = [];
                $md5s  = 0;
            }
        }
        $count += 1;
        $md5s  += 1;
        $curr  = $md5;
        $start = $byte;
        $size  = 0;
    }
    $byte += length $line;
    $size += length $line;
}
close INFILE;

if (scalar(@$seeks) > 0) {
    if ($size > 0) {
        push @$seeks, [ $curr, $start, $size ];
    }
    print OUTFILE &process_seeks($ach, $seeks);
}

print "Done - $count md5s indexed\n" if ($verbose);
exit 0;

sub process_seeks {
    my ($ach, $seeks) = @_;
    
    my $out  = '';
    my @keys = map { $_->[0] } @$seeks;
    my $curs = $ach->find({ 'key' => { '$in' => [@keys] } });
    my %data = map { $_->{key}, $_->{data} } $curs->all;
    
    foreach my $set (@$seeks) {
        my ($md5, $start, $size) = @$set;
        if (exists($data{$md5}) && exists($data{$md5}{id})) {
            $out .= join("\t", ($data{$md5}{id}, $start, $size))."\n";
        }
    }
    return $out;
}


